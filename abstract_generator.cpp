/*
 *
 * Copyright 2017, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "abstract_generator.h"

#include <set>

// Static helper
static bool StripSuffix(grpc::string *filename, const grpc::string &suffix) {
  if (filename->length() >= suffix.length()) {
    size_t suffix_pos = filename->length() - suffix.length();
    if (filename->compare(suffix_pos, grpc::string::npos, suffix) == 0) {
      filename->resize(filename->size() - suffix.size());
      return true;
    }
  }

  return false;
}

// Static helper. "helloworld.proto" -> "helloworld"
static grpc::string StripProto(grpc::string filename) {
  if (!StripSuffix(&filename, ".protodevel")) {
    StripSuffix(&filename, ".proto");
  }
  return filename;
}

grpc::string StringReplace(grpc::string str, const grpc::string &from,
                                  const grpc::string &to, bool replace_all) {
  size_t pos = 0;

  do {
    pos = str.find(from, pos);
    if (pos == grpc::string::npos) {
      break;
    }
    str.replace(pos, from.length(), to);
    pos += to.length();
  } while (replace_all);

  return str;
}

static grpc::string StringReplace(grpc::string str, const grpc::string &from,
                                  const grpc::string &to) {
  return StringReplace(str, from, to, true);
}

static grpc::string DotsToColons(const grpc::string &name) {
  return StringReplace(name, ".", "::");
}

static grpc::string DotsToUnderscores(const grpc::string &name) {
  return StringReplace(name, ".", "_");
}

static grpc::string ClassName(const grpc::protobuf::Descriptor *descriptor,
                              bool qualified) {
  // Find "outer", the descriptor of the top-level message in which
  // "descriptor" is embedded.
  const grpc::protobuf::Descriptor *outer = descriptor;
  while (outer->containing_type() != NULL) outer = outer->containing_type();

  const grpc::string &outer_name = outer->full_name();
  grpc::string inner_name = descriptor->full_name().substr(outer_name.size());

  if (qualified) {
    return "::" + DotsToColons(outer_name) + DotsToUnderscores(inner_name);
  } else {
    return outer->name() + DotsToUnderscores(inner_name);
  }
}

grpc::string AbstractGenerator::GenerateHeaders() const
{
  grpc::string output;
  {
    // scoped printer
    Printer printer(&output);

    vars_t vars;
    vars["proto_filename"] = file->name();
    vars["proto_filename_without_ext"] = StripProto(file->name());

    PrintComment(printer, "Generated by the gRPC client protobuf plugin.");
    PrintComment(printer, "If you make any local change, they will be lost.");
    PrintComment(printer, vars, "source: $proto_filename$");

    printer.NewLine();

    PrintPackage(printer, vars);
    PrintIncludes(printer, vars);
    PrintFlags(printer, vars);
  }
  return output;
}

static void RecursivlyTrackMessages(
  const grpc::protobuf::Descriptor* message,
  std::set<const grpc::protobuf::Descriptor*> &message_set)
{
  // already tracking this method
  if (message_set.find(message) != message_set.end())
    return;

  message_set.insert(message);

  for (int i = 0; i < message->field_count(); ++i) {
    auto field = message->field(i);
    if (field->type() == grpc::protobuf::FieldDescriptor::Type::TYPE_MESSAGE) {
      RecursivlyTrackMessages(field->message_type(), message_set);
    }
  }
}

void AbstractGenerator::PrintMessagePopulatingFunctionDecl(
    const grpc::protobuf::Descriptor *message, Printer &printer) const
{
  vars_t vars;
  vars["type"] = ClassName(message, true);
  vars["name"] = message->name();
  DoPrintMessagePopulatingFunctionDecl(printer, vars);
}

void AbstractGenerator::PrintMessagePrintingFunctionDecl(
    const grpc::protobuf::Descriptor *message, Printer &printer) const
{
  vars_t vars;
  vars["type"] = ClassName(message, true);
  vars["name"] = message->name();
  DoPrintMessagePrintingFunctionDecl(printer, vars);
}

void AbstractGenerator::PrintMessagePopulatingFunction(
    const grpc::protobuf::Descriptor *message, Printer &printer) const
{

}

void AbstractGenerator::PrintMessagePrintingFunction(
    const grpc::protobuf::Descriptor *message, Printer &printer) const
{
  
}

grpc::string AbstractGenerator::GenerateMessagePopulationFunctions() const
{
  std::set<const grpc::protobuf::Descriptor*> input_messages;
  std::set<const grpc::protobuf::Descriptor*> output_messages;
  for (int i = 0; i < file->service_count(); ++i) {
    auto service = file->service(i);
    for (int j = 0; j < service->method_count(); ++j) {
      auto method = service->method(j);
      RecursivlyTrackMessages(method->input_type(), input_messages);
      RecursivlyTrackMessages(method->output_type(), output_messages);
    }
  }
  grpc::string output;
  {
    Printer printer(&output);
    for (auto it = input_messages.begin(); 
        it != input_messages.end(); ++it) {
      PrintMessagePopulatingFunctionDecl(*it, printer);
    }
    for (auto it = output_messages.begin(); 
        it != output_messages.end(); ++it) {
      PrintMessagePrintingFunctionDecl(*it, printer);
    }
    for (auto it = input_messages.begin(); 
        it != input_messages.end(); ++it) {
      PrintMessagePopulatingFunction(*it, printer);
    }
    for (auto it = output_messages.begin(); 
        it != output_messages.end(); ++it) {
      PrintMessagePrintingFunction(*it, printer);
    }
    printer.NewLine();
  }
  return output;
}

void AbstractGenerator::PrintMethodProbeFunction(
    const grpc::protobuf::MethodDescriptor *method,
    Printer &printer, vars_t &vars) const
{

}

void AbstractGenerator::PrintMethodProbeCall(
    const grpc::protobuf::MethodDescriptor *method,
    Printer &printer, vars_t &vars) const
{

}

void AbstractGenerator::PrintServiceProbe(
    const grpc::protobuf::ServiceDescriptor *service, Printer &printer) const
{
  // dump in all interesting per-service info
  vars_t vars;

  // generate the method probing functions
  for (int i = 0; i < service->method_count(); ++i) {
    PrintMethodProbeFunction(service->method(i), printer, vars);
  }

  // call the method probing functions
  for (int i = 0; i < service->method_count(); ++i) {
    PrintMethodProbeCall(service->method(i), printer, vars);
  }
}

grpc::string AbstractGenerator::GenerateServiceProbeFunctions() const
{
  grpc::string output;
  {
    Printer printer(&output);
    for (int i = 0; i < file->service_count(); ++i) {
      PrintServiceProbe(file->service(i), printer);
    }
  }
  return output;
}

grpc::string AbstractGenerator::GenerateMain() const
{
  grpc::string output;
  {
    Printer printer(&output);
    StartMain(printer);
    printer.NewLine();
    EndMain(printer);
  }
  return output;
}

grpc::string AbstractGenerator::GenerateProberClient() const
{
  return GenerateHeaders()                    +
         GenerateMessagePopulationFunctions() +
         GenerateServiceProbeFunctions()      +
         GenerateMain();
}

grpc::string AbstractGenerator::GetProtoName() const
{
  return StripProto(file->name());
}

void AbstractGenerator::PrintComment(Printer &printer, 
    vars_t &vars, grpc::string str) const {
  grpc::string with_prefix = GetCommentPrefix() + str + "\n";
  printer.Print(vars, with_prefix.c_str());
}

void AbstractGenerator::PrintComment(Printer &printer, 
    grpc::string str) const {
  grpc::string with_prefix = GetCommentPrefix() + str + "\n";
  printer.Print(with_prefix.c_str());
}

// this function is called by the protobuf infrastructure when the protoc
// binary is invoked with this plugin. It will call the internal generation
// function, then write the generated output file
bool AbstractGenerator::Generate(const grpc::protobuf::FileDescriptor *file_,
                      const grpc::string &parameter,
                      grpc::protobuf::compiler::GeneratorContext *context,
                      grpc::string *error) const
{
  file = file_; // set member so children can access it
  grpc::string generated_file = GenerateProberClient();
  grpc::string file_name = GetProtoName() + GetLanguageSpecificFileExtension();
  std::unique_ptr<grpc::protobuf::io::ZeroCopyOutputStream> client_output(
      context->Open(file_name));
  grpc::protobuf::io::CodedOutputStream client_coded_out(client_output.get());
  client_coded_out.WriteRaw(generated_file.data(), generated_file.size());
  return true;
}


